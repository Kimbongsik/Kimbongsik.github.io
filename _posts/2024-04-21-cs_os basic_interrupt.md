---
title: "[운영체제] [Basic] 인터럽트 기반의 OS"
last_modified_at: 2024-04-21T16:20:02-05:00
toc: true
toc_sticky: true
toc_label: "목차"
categories:
  - cs

tags:
  - cs
---

## 운영체제란

### 운영체제의 기능

1. 컴퓨터 하드웨어를 관리함. (Processork, memory, hard disk..)
2. 성능을 향상 시킴.
3. 사용자에게 편의를 제공함. 

### Booting

1. 컴퓨터를 전원이 켜진다.
2. ROM(비휘발성 메모리)에 있는 코드가 실행되어 POST(Power-on self-test) 과정이 실행된다.
3. ROM안에 있는 Boot Loader가 실행된다. OS는 하드 디스크 안에 설치하는데, Boot Loader는 하드 디스크를 읽어 os를 메인 메모리의 RAM으로 가져온다.  
->이제 ROM은 할 거 없음.  

OS가 메인 메모리로 올라오면, 윈도우 기준 바탕화면이 뜨고 아이콘 등이 보이게 되고 이 때부터 대부분의 명령을 OS가 제어한다.
다른 프로그램들은 메모리에 올라왔다가 사라지는 반면, 올라온 OS는 컴퓨터 전원을 끌 때 사라진다. 예를 들어 hwp 프로그램을 사용하기 위해 프로그램을 열면
hwp가 메인 메모리로 올라오고, 문서 작업을 마치고 창을 닫으면 메모리에서 사라진다. 그러나 os는 컴퓨터를 가동시킬 때 계속 상주하므로, 이를 메모리에 resident(상주)한다고 한다.

### Kernal & Shell

OS는 크게 Kernal 부분과 Shell 부분으로 나뉜다. Kernal은 핵심적으로 관리하는 부분으로, CPU와 메모리, 디스크 등을 관리한다. 
Shell은 명령을 담당하는데, 예를 들어 바탕화면에서 아이콘을 마우스로 클릭하는 것 등이 여기에 해당된다. 따라서 Shell은 다른 말로 Command interpreter라고 한다.
리눅스의 경우 하다 디스크의 전체 용량과 사용 용량 등의 정보를 알기 위해 명령어 $df 를 사용하는데, 이런 명령어가 들어가면 shell이 동작하여 해당 명령을 수행한다.
흔히 윈도우 좀 한다..라고 하는 건 윈도우 Shell을 쓸 줄 안다고 하는 것..

운영체제의 간략한 위치는 다음과 같다. 

Hard Ware > OS(Kernal&Shell) > Application  
App들은 OS 위에서 움직인다.  

### Management

많은 걸 관리한다. 약간 관리 부서 느낌?  
1. Processer management
2. Memory management
3. I/O management
4. File management
5. Network management
6. Security(Protection) maangement

## 인터럽트 기반 시스템

CPU는 인터럽트라는 매커니즘으로 관리된다. 물론 주변 장치, 입출력 장치도. 입출력 연산이 CPU의 명령 수행속도보다 훨씬 느리기 때문에, 매번 입출력 연산을 기다리게 되면
CPU 낭비가 심하다.  따라서 입출력 연산이 마무리 됐을 때 CPU에게 작업이 끝났다고 알려라.. 이런 느낌이다. 
좀 더 깔끔하게 적어보면,  
-> CPU가 프로그램을 실행 중일 때, 입출력 하드웨어 장치 등의 처리가 필요할 때 micro processor에게 알려 처리할 수 있도록 하는 것이다.

크게 세 가지로 나뉜다.

* 하드웨어 인터럽트
* 소프트웨어 인터럽트
* 내부 인터럽트

### 인터럽트 유형

1. 하드웨어 인터럽트  
하드웨어가 발생 시키는 인터럽트. OS는 상시 대기 상태이다. 우리가 마우스를 움직이면 마우스에서 전기 신호가 발생하여 CPU에 전기신호를 보내준다(직접 파직하고 주는 건 아닌데 논리적으로 그렇다).  
그럼 OS는 지금 하던 일을 중지하고, 바로 마우스를 움직인다. OS 안에 마우스가 전기신호를 보낼 때 어떻게 해야 하는지에 대한 정보가 있는데, 이걸 mouse Interrupt Service Routin(ISR)라고 한다.  
만약 아래 한글의 아이콘에 더블 클릭을 한다면, IRS는 해당 좌표에 해당하는 아이콘을 감지하고 하드 디스크를 뒤져서 hwp를 찾아 메인 메모리에 올린다. 

2. 소프트웨어 인터럽트  
소프트웨어가 발생 시키는 인터럽트. 이번엔 파일을 읽어온다고 하자. 하드 디스크에 hi.hwp라는 파일이 있다. hwp 프로그램이 이 때 software interrupt를 걸면, OS 안에 있는 코드가 실행되어 하드 디스크에서 파일을 가져와 올린다. 파일을 읽고 실행을 종료하면 다시 돌아온다. 

3. 내부 인터럽트
C로 작성한 간단한 코드가 있다고 생각해보자. 어떤 변수에 정수를 0으로 나눈 값, 즉 무한대의 값을 저장하려고 한다.   이런 사건이 일어나면 값을 처리하기 곤란하기 때문에, 내부적으로 interrupt가 발생했다고 생각하여 os 안에 devide by zero라는 IRS가 실행된다. 이렇듯 잘못된 데이터를 사용할 때 발생되는 인터럽트를 내부 인터럽트라 한다. Overflow, Underflow 등이 해당된다.

인터럽트를 발생시키기 위해서는 sw/hw 가 cpu에 있는 인터럽트 라인을 세팅하여 발생시킨다. 과정을 살펴보자.

### 인터럽트 과정  

1. 인터럽트 요청 신호가 들어옴.
2. CPU는 프로그램 수행을 중단.
-현재 수행 중인 명령의 수행이 끝난 시점에서 중단된다. 주기억 장치 사이클이 끝나는 시점X
3. 현재 수행 중이었던 상태를 저장하고 PC에 다음 실행할 명령의 주소를 저장. 
4. 인터럽트 벡터를 읽은 뒤 ISR 주소값을 얻어 ISR를 호출.
5. 코드 실행
6. 해당 코드 처리 후, 대피 시켰던 레지스터 복원.
7. IRET 명령어 실행 뒤 대피시킨 PC 값을 복원하여 이전 실행 위치로 복원.  
