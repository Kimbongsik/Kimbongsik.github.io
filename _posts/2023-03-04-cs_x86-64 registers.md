---
title: "[컴퓨터구조] x86-64 아키텍쳐: 레지스터"
last_modified_at: 2023-03-04T16:20:02-05:00
toc: true
toc_sticky: true
toc_label: "목차"
categories:
  - cs

tags:
  - cs
---


# x86-64 아키텍쳐: 레지스터

## 범용 레지스터

8바이트 저장 가능. 부호 없는 정수 기준 2^64 - 1까지의 수를 나타낼 수 있음.

주용도:

rax(accumulator register) : 함수의 반환값

rbx(base register): x86에서는 주된 용도 없음

rcx(counter register): 반복문의 반복 횟수, 각종 연산의 시행 횟수

rdx(data register): x64에서는 주된 용도 없음

rsi(source indx): 데이터를 옮길 때 원본을 가리키는 포인터

rdi(detination index): 데이터를 옮길 때 목적지를 가리키는 포인터

rsp(stack pointer): 사용 중인 스택의 위치를 가리키는 포인터

rbp(stack base pointer): 스택의 바닥을 가리키는 포인터
<br/>

## 세그먼트 레지스터

cs,ss,ds,es,fs,gs 총 6개의 세그먼트 레지스터 존재. 각 레지스터의 크기는 16비트. 세그먼트 레지스터는 x64로 아키텍처가 확장되면서 용도에 큰 변화가 생긴 레지스터. 

과거 IA-32, IA-16에서는 세그먼트 레지스터를 이용하여 사용 가능한 물리 메모리의 크기를 키우려고함. 예를들어 IA-16에서 어떤 주소를 cs:offset이라고 할 때 실제로는 cs<<4+offset의 주소를 사용하여 16비트 범위에서 접근할 수 없는 주소에 접근할 수 있었음. 당시에는 범용 레지스터의 크기가 작아 사용 가능한 메모리의 주소 폭이 좁았지만 x64에서는 사용 가능한 주소 영역이 넓어 이 용도로는 거의 사용되지 않음.

현대의 x64에서 cs,ds,ss 레지스터는 코드영역과 데이터, 스택 메모리 영역을 가리킬 때 사용되고, 나머지 레지스터는 운영체제 별로 *용도를 결정할 수 있도록 범용적인 용도로 제작된 세그먼트 레지스터임.*

<br/>

## 명령어 포인터 레지스터

기계어 코드들에서 CPU가 어느 부분의 코드를 실행할지 가리키는 게 명령어 포인터(Intsruction Pointer==Program Counter) 레지스터의 역할. x64 아키텍처의 명령어 레지스터는 rip며 크기는 8바이트임. 

## 플래그 레지스터

프로세서의 현재 상태를 저장하고 있는 레지스터. x64 아키텍쳐에서는 RFLAGS라고 불리는 64비트 크기의 플래그 레지스터가 존재함. 자신을 구성하는 여러 비트들로 CPU의 현재 상태를 표현함. RFLAGS는 64비트이므로 최대 64개의 플래그를 사용할 수 있지만, 실제로는 오른쪽의 20여개의 비트만 사용함. 주요 플래그는 다음과 같음. 

:

CF(Carry Flag): 부호 없는 수의 연산 결과가 비트의 범위를 넘을 경우 설정됨.

ZF(Zero Flag): 연산의 결과가 0일 경우 설정됨. 

SF(Sign Flag): 연산의 결과가 음수일 경우 설정됨. 

OF(Overflow Flag): 부호 있는 수의 연산 결과가 비트 범위를 넘을 경우 설정됨.

예를 들어 a-b의 연산결과가 음수이면 SF가 설정되고 CPU는 SF를 통해 a가 b보다 작았음을 알 수 있음.

<br/>

## 레지스터 호환

x86-64 아키텍쳐는 IA-32의 64비트 확장 아키텍쳐이고 호환이 가능함. IA-32에서 CPU의 레지스터들은 32비트 크기를 가지며 이들의 명칭은 eax,ebx,,, 등인데 이 레지스터들은 x86-64에서도 사용이 가능함. rax, rbx 등이 이들의 확장된 형태. 다른 예로, 과거 16비트 아키텍쳐인 IA-16과의 호환을 위해 ax, bx, cx는 eax, ebx, ecx,의 하위 16비트를 가리킨다고 보면 됩니다.
