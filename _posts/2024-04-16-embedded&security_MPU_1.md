---
title: "[임베디드/보안] MPU(Memory Protection Unit)란? [1]"
last_modified_at: 2024-04-16T16:20:02-05:00
toc: true
toc_sticky: true
toc_label: "목차"
categories:
  - embedded
  - security

tags:
  - embedded
  - security
---

# Memory Protection(x86 시스템의 경우)

자. 임베디드를 하다보면 MPU라는 녀석을 자주 마주칠 수밖에 없다.

일반적인 PC 환경(x86이라고 칭하자)과 달리 임베디드 시스템은 메모리를 포함한 하드웨어 자원이 한정적이기 때문에 MMU를 기반으로 한 가상 메모리 기능을 지원하지 않는다.

가상 메모리 기능의 장점은 무엇이지?

물론, 메모리가 마치 확장된 것처럼 보이게 만들어 여러 개의 큰 프로그램들을 동시에 돌릴 수 있도록 하는 것도 큰 장점이지만, 보안 측면에서 보았을 때 **페이지 별로 권한 설정**이 가능하다는 것도 큰 장점 중 하나이다.

프로세스는 ‘code / data / heap / bss / stack’ 영역을 가지고 있다는 것을 알고 있을 것이다. 이때 메모리는 페이지 단위로 권한 비트 R/W/X (4/2/1)로 권한을 관리한다. 이는 Page Table에 권한 비트 및 프레임 번호가 기록되어 있어 가능한 일이다.

예를 들어 Stack, Heap, Bss 영역은 데이터가 쓰여야 하므로 RW-로 지정하고, Code 및 Data 영역의 경우 Read 권한(R—)만 부여함으로써 프로세스의 메모리 공간을 보호하는 방식으로 동작한다.

# Memory Protection(Real-Time 시스템의 경우)

그럼 다시 돌아와서, 

이런 페이징 관리 기법이 존재하지 않는 임베디드 시스템에서는 메모리 관리를 어떻게 하고 있을까?

안타깝게도, 잘 안 하고 있다. 정확히 말해서는 메모리 보호 기법들이 존재하고(TEE를 사용한다든지), 사용되고 있기는 하지만 Real-Time System의 경우 Deadline을 맞추기 위해 성능에 몰빵하다보니 OS에서 memory protection을 수행 안 하는 경우가 태반이다([MINION 논문 참조](https://kimbongsik.github.io/papers/2024/04/14/paper_MINION.html))..

이때 칩 벤더에서 메모리 보호를 위해 지원하는 하드웨어 기능이 있는데, 바로 MPU(Memory Protection Unit)이다.

# MPU

MPU는 위에서 언급했듯, 메모리 보호를 위해 존재하는 하드웨어 유닛이다. 그럼 어떤 방식으로 메모리를 보호할까?

MPU는 프로세스 별로 권한을 나누는 것이 아닌, 메모리 자체를 여러 개의 영역으로 분할한다. 

그리고 이 영역 별로 권한을 부여하고, OS는 이 MPU를 포팅하여 사용함으로써 태스크 별로 권한을 관리하게 된다. 

MPU에서 지원하는 영역의 개수는 한정되어 있으며 각 지역에 대한 base address, size, 속성, 권한을 지정하여 프로그래밍 할 수 있다.

MPU는 ARMv7 이상의 버전의 아키텍처들에 탑재되어 있다.  






이번에는 MPU가 무엇인지, 왜 사용하는지 간단하게 알아보았고 다음 포스팅에서는 어떻게 사용하는지에 대해서 좀 더 자세히 다뤄보겠다.