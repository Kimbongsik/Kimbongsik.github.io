---
title: "[C/C++] 헤더 파일 vs 라이브러리"
last_modified_at: 2023-01-26T16:20:02-05:00
categories:
  - C_C++

tags:
  - C/C++
---

헤더파일과 라이브러리는 엄연히 다르다.

이걸 설명할 수 있느냐 없느냐의 차이도 큰 것 같다.

# 헤더파일의 정의

일반적으로 소프트웨어 공학에서 말하는 모듈은 하나의 파일, 또는 함수일 수 있다. 구현하는 프로그램 코드를 기능별로 적절히 나눠 독립된 파일에 저장하여 관리하며, 이렇게 관리되는 파일을 모듈이라고 한다. 이러한 방식으로 프로그래밍하는 것을 ‘모듈화 프로그래밍’이라고 한다. 

```c
#include <stdio.h>

int i = 0;
int main()
{
	i++;
	printf("%d \n", i);
	return 0;
}
```

이것을 두 개의 파일로 분리하면, 

file_1.c

```c
int i = 0;
```

file_2.c

```c
#include <stdio.h>

extern int i; //변수 또는 함수가 다른 파일에 선언되어 있음을 컴파일러에게 알림

int main()
{
	i++;
	printf("%d \n",i);
	return 0;
}
```

- **static** : extern 함수는 static 선언이 되어 있는 변수에게는 사용할 수 없다. 전역변수 앞에 static을 선언하게 될 경우 변수의 접근 영역을 파일로 제한하기 때문에, 다른 파일에서 extern 선언을 해도 접근이 불가능한 전역변수가 된다.
- **link** : 파일을 컴파일하면 각각 오브젝트 파일이 생성되고, 이 오브젝트 파일은 기계어로 변환된 내용만을 지니고 실행 자체는 불가능하다. 따라서 extern int i에서는 maain 함수 내에서 접근하고 있는 변수 i가 외부에 존재한다는 정보만을 담고 있으며, 변수 i가 외부 어디에 존재하는지는 모른다. 따라서 main 함수에서 접근하고 있는 i와 이 i를 선언하고 있는 다른 오브젝트 파일의 전역변수 i를 연결시켜줘야 하는데, **최종적인 실행 파일의 생성을 위해 접근하는 변수의 위치와 호출하는 함수 위치를 연결해주는 작업을 가리켜 링크라고 한다.**

→ 헤더파일은 extern int i와 같이 main 함수나 다른 파일에서 선언해야 하는 외부 변수가 매우 많은 경우 번거로운 일을 줄이기 위해 헤더 파일이란 것을 선언하여 사용한다.

```c
/* file_1.c */
int i = 0;

/* file_1.h */
extern int i;

/* file_2.c */
#include <stdio.h>
#include "file_1.h"

int main(void) 
{   
	i++;    
	printf("%d \n", i);   
	return 0;
}

```

# 헤더파일 vs 라이브러리

- 헤더파일: c/c++로 짜여있는 선언들의 집합
- 라이브러리: 바이너리
- 헤더가 여러 개 모이는 것이 라이브러리가 아니라, 라이브러리는 컴파일 된 바이너리이기 때문에 소스 파일의 컴파일 된 결과인 오브젝트(ex: 리눅스: .o) 파일을 여러 개 모아둔 것.
- 라이브러리를 다른 파일과 링크하면, 선언된 라이브러리 함수만이 실행파일에 포함된다.
- 파일에 함수를 작성해두고 컴파일 하여 두 파일을 링크시키면 불필요한 함수까지 코드로 첨가된다.
- → 라이브러리는 디스크 공간과 주 메모리를 절약하는 데 필요하다
- 라이브러리는 대부분 함수 정의 및 선언을 하기 때문에 링크되기 전에 선처리기로 인해 해당 헤더파일을 원시 프로그램에 포함 시켜야 한다

<aside>
💡 참고 사이트: 열혈강의 C 프로그래밍,  [https://linuxism.ustd.ip.or.kr/344]

</aside>
